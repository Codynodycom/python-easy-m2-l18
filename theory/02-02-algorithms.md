## Визуализация

Посмотреть визуализацию всех алгоритмов можно по ссылке:

https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

# Сортировка пузырьком (Bubble Sort)

Этот алгоритм является одним из простейших алгоритмов сортировки. Он получил свое название благодаря тому, что наибольшие элементы "всплывают" (перемещаются) на свои позиции, как пузырьки воды всплывают на поверхность.

### Принцип работы алгоритма:

1. Проходим по списку элементов.
2. Сравниваем каждую пару соседних элементов.
3. Если элементы стоят в неправильном порядке, меняем их местами.
4. Повторяем `шаги 1-3` до тех пор, пока список не будет отсортирован.

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # Проходим по массиву до n-i-1,
        # так как после каждой итерации
        # наибольший элемент становится на свое место.
        for j in range(0, n-i-1):
            # Сравниваем соседние элементы
            if arr[j] > arr[j+1]:
                # Если текущий элемент больше следующего,
                # меняем их местами.
                arr[j], arr[j+1] = arr[j+1], arr[j]

# Пример использования функции сортировки пузырьком
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Отсортированный массив:")
for i in range(len(arr)):
    print("%d" % arr[i]),
```

В данном примере функция `bubble_sort` принимает массив `arr` и сортирует его по возрастанию. После сортировки массив выводится на экран.

Этот алгоритм прост в понимании и реализации, но неэффективен на больших объемах данных из-за своей квадратичной временной сложности.

# Сортировка вставками (Insertion Sort)

Работает путем поочередного добавления элементов в отсортированную часть массива. По мере прохода по массиву каждый новый элемент вставляется на свое место среди уже отсортированных элементов.

### Принцип работы алгоритма:

1. Начинаем с пустого списка или массива, который считается отсортированным.
2. Последовательно берем каждый элемент из неотсортированной части массива и вставляем его в нужное место в отсортированной части.
3. Повторяем `шаг 2` для всех элементов в неотсортированной части.

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        # Запоминаем текущий элемент для вставки
        key = arr[i]
        # Начинаем сравнивать его с элементами перед ним
        j = i - 1
        # Перемещаем все элементы больше key на одну позицию вперед
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        # Вставляем key в правильное место
        arr[j + 1] = key

# Пример использования функции сортировки вставками
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print("Отсортированный массив:")
for i in range(len(arr)):
    print("%d" % arr[i]),
```

В данном примере функция `insertion_sort` принимает массив `arr` и сортирует его по возрастанию с помощью сортировки вставками. После сортировки массив выводится на экран.

Этот алгоритм эффективен на небольших массивах и имеет временную сложность `O(n^2)`, что делает его хорошим выбором для небольших наборов данных.

# Сортировка выбором (Selection Sort)

Работает путем выбора наименьшего (или наибольшего) элемента из списка и перемещения его в начало (или конец) списка. После этого алгоритм продолжает выбирать наименьшие (или наибольшие) элементы из оставшейся части списка и перемещать их на соответствующие позиции.

### Принцип работы алгоритма:

1. Начинаем с пустого списка или массива, который считается отсортированным.
2. На каждом шаге алгоритма выбираем наименьший (или наибольший) элемент из оставшейся части списка и перемещаем его в начало (или конец) отсортированной части.
3. Повторяем `шаг 2` до тех пор, пока весь список не будет отсортирован.

```python
def selection_sort(arr):
    # Проходим по всем элементам списка, кроме последнего
    for i in range(len(arr) - 1):
        # Ищем наименьший элемент в оставшейся части списка
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        # Меняем местами текущий элемент с найденным минимальным элементом
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# Пример использования функции сортировки выбором
arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print("Отсортированный массив:")
for i in range(len(arr)):
    print("%d" % arr[i]),
```

В данном примере функция `selection_sort` принимает массив `arr` и сортирует его по возрастанию с помощью сортировки выбором. После сортировки массив выводится на экран.

Этот алгоритм эффективен на небольших массивах и имеет временную сложность `O(n^2)`, что делает его хорошим выбором для небольших наборов данных.

# Сортировка слиянием (Merge Sort)

Алгоритм "Сортировка слиянием" (Merge Sort) относится к классу алгоритмов "разделяй и властвуй". Он работает путем разделения исходного списка на меньшие подсписки, сортировки каждого из них отдельно, а затем объединения отсортированных подсписков в один отсортированный список.

### Принцип работы алгоритма:

1. Разделяем исходный список на две равные (или почти равные) части.
2. Рекурсивно сортируем каждую из частей.
3. Объединяем отсортированные части в один отсортированный список.

```python
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        # Рекурсивно сортируем левую и правую половины списка
        merge_sort(left_half)
        merge_sort(right_half)

        # Слияние отсортированных половин
        i = j = k = 0
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        # Проверяем, остались ли элементы в левой и правой половинах
        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1
        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

# Пример использования функции сортировки слиянием
arr = [12, 11, 13, 5, 6, 7]
print("Исходный массив:", arr)
merge_sort(arr)
print("Отсортированный массив:", arr)
```

Этот код сначала разделяет список на половины, затем рекурсивно сортирует каждую половину и, наконец, сливает их в один отсортированный список.

# Что такое рекурсия

Это процесс, при котором функция вызывает саму себя непосредственно или через другие функции.

```python
def factorial(n):
    # Базовый случай: если n равно 0 или 1, возвращаем 1
    if n == 0 or n == 1:
        return 1
    # Рекурсивный случай: умножаем n на результат вызова функции factorial для (n-1)
    else:
        return n * factorial(n-1)

# Пример использования функции factorial
num = 5
print("Факториал числа", num, "равен", factorial(num))
```
В этом примере функция `factorial()` вычисляет факториал числа n. Если n равно `0` или `1`, возвращается `1` (базовый случай). В противном случае (рекурсивный случай) функция вызывает саму себя для числа `(n-1)` и умножает результат на `n`. Таким образом, факториал числа `n` вычисляется путем рекурсивного умножения всех чисел от `n` до `1`.

Когда функция `factorial()` вызывается для числа `5`, происходит следующее:

1. Функция проверяет, не равно ли `n` `нулю` или `1`. Нет, поэтому она переходит к следующему шагу.
2. Функция вызывает себя для числа `4` и умножает результат на `5`.
3. Этот процесс повторяется, пока не достигнут базовый случай (когда `n` становится равным `1`).
4. Функция возвращает результаты рекурсивных вызовов, умноженные на `n`, что дает факториал числа `5`.

# Быстрая сортировка (Quick Sort)

Алгоритм быстрой сортировки (Quick Sort) является одним из самых эффективных алгоритмов сортировки. Он использует стратегию **"разделяй и властвуй"**, разбивая массив на подмассивы, сортируя их отдельно, а затем объединяя отсортированные подмассивы весь массив.

### Описание алгоритма:

1. Выбирается опорный элемент из массива. Обычно это средний элемент.
2. сив разбивается на две части: элементы меньше опорного и элементы больше опорного.
3. Рекурсивно применяется алгоритм для каждой из частей.
4. В конце объединяются отсортированные части.

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[len(arr) // 2] # Опорный элемент
        less = [x for x in arr if x < pivot]
        equal = [x for x in arr if x == pivot]
        greater = [x for x in arr if x > pivot]
        return quick_sort(less) + equal + quick_sort(greater)

# Пример использования
arr = [3, 6, 8, 10, 1, 2, 1]
print("Исходный массив:", arr)
sorted_arr = quick_sort(arr)
print("Отсортированный массив:", sorted_arr)
```

- Функция `quick_sort()` принимает массив `arr` и возвращает отсортированный массив.
- Если длина массива меньше или равна `1`, возвращается сам массив.
- Иначе выбирается опорный элемент (`pivot`) - это средний элемент массива.
- Затем создаются три подмассива: `less` (меньше `pivot`), `equal` (равные `pivot`) и `greater` (больше `pivot`).
- Рекурсивно вызывается `quick_sort()` для подмассивов `less` и `greater`.
- Возвращается объединение отсортированных `less`, `equal` и `greater`.

Алгоритм быстрой сортировки эффективен и быстр, особенно на больших наборах данных, но может иметь низкую производительность на отсортированных массивах или массивах с повторяющимися элементами.

# Сортировка подсчетом (Counting Sort)

Алгоритм сортировки подсчетом (Counting Sort) относится к сортировкам подсчета, которые эффективно сортируют целочисленные массивы, когда известен диапазон значений входных данных.

### Описание алгоритма:

1. Определите диапазон входных данных (минимальное и максимальное значения).
2. Создайте массив подсчета (count), который будет содержать количество вхождений каждого элемента входного массива.
3. Пройдите по входному массиву и увеличьте соответствующий счетчик в массиве подсчета.
4. Выполните суммирование элементов массива подсчета, чтобы определить положение каждого элемента в отсортированном массиве.
5. Создайте выходной массив и поместите каждый элемент в правильное место, используя массив подсчета.

```python
def counting_sort(arr):
    # Находим минимальное и максимальное значения в массиве
    min_val = min(arr)
    max_val = max(arr)
    
    # Создаем массив подсчета с нулями для каждого возможного элемента
    count = [0] * (max_val - min_val + 1)
    
    # Считаем количество вхождений каждого элемента в массиве
    for num in arr:
        count[num - min_val] += 1
    
    # Создаем отсортированный массив
    sorted_arr = []
    for i in range(len(count)):
        sorted_arr.extend([i + min_val] * count[i])
    
    return sorted_arr

# Пример использования
arr = [4, 2, 2, 8, 3, 3, 1]
print("Исходный массив:", arr)
sorted_arr = counting_sort(arr)
print("Отсортированный массив:", sorted_arr)
```

- Функция `counting_sort()` принимает массив `arr` и возвращает отсортированный массив.
- Определяется диапазон значений входного массива (`min_val` и `max_val`).
- Создается массив подсчета count длиной `max_val - min_val + 1`.
- Происходит подсчет количества вхождений каждого элемента в массиве.
- Создается отсортированный массив `sorted_arr` на основе массива подсчета.

Алгоритм сортировки подсчетом эффективен, когда диапазон значений входных данных относительно небольшой, но может потребовать много дополнительной памяти при больших диапазонах значений.
